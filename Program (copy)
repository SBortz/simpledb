using System.Text;

if (args.Length == 0)
{
    Console.Error.WriteLine("""
    Usage:
      dotnet run -- set <key:int> <value>
      dotnet run -- get <key:int>
      dotnet run -- fill [size: e.g. 2g|2048m|2000000000] [minLen] [maxLen]
    """);
    return;
}

var file = "database.bin";
var cmd  = args[0].ToLowerInvariant();

switch (cmd)
{
    case "set":
        if (args.Length < 3) { Console.Error.WriteLine("set <key:int> <value>"); return; }
        Set(int.Parse(args[1]), args[2]);
        break;

    case "get":
        if (args.Length < 2) { Console.Error.WriteLine("get <key:int>"); return; }
        Get(int.Parse(args[1]));
        break;

    case "fill":
        {
            // Defaults: ~2 GB, Werte zwischen 16 und 64 Bytes
            long targetBytes = args.Length >= 2 ? ParseSize(args[1]) : (2L << 30); // ~2 GiB
            int minLen = args.Length >= 3 ? int.Parse(args[2]) : 16;
            int maxLen = args.Length >= 4 ? int.Parse(args[3]) : 64;
            if (minLen < 1 || maxLen < minLen) { Console.Error.WriteLine("fill [size] [minLen] [maxLen]"); return; }
            Fill(targetBytes, minLen, maxLen);
            break;
        }

    default:
        Console.Error.WriteLine("Unknown command.");
        break;
}

static void Set(int key, string value)
{
    byte[] data = Encoding.UTF8.GetBytes(value);
    using var fs = new FileStream("database.bin", FileMode.Append, FileAccess.Write, FileShare.Read, bufferSize: 1 << 20, options: FileOptions.SequentialScan);
    using var bw = new BinaryWriter(fs, Encoding.UTF8, leaveOpen: false);
    bw.Write(key);
    bw.Write(data.Length);
    bw.Write(data);
}

static void Get(int searchKey)
{
    string? last = null;
    using var fs = new FileStream("database.bin", FileMode.OpenOrCreate, FileAccess.Read, FileShare.ReadWrite, bufferSize: 1 << 20, options: FileOptions.SequentialScan);
    using var br = new BinaryReader(fs, Encoding.UTF8, leaveOpen: false);

    while (fs.Position < fs.Length)
    {
        int key = br.ReadInt32();
        int len = br.ReadInt32();
        var buf = br.ReadBytes(len);
        if (key == searchKey)
            last = Encoding.UTF8.GetString(buf);
    }
    if (last != null) Console.WriteLine(last);
}

static void Fill(long targetBytes, int minLen, int maxLen)
{
    // wir hängen an; falls Datei schon existiert, geht's ab aktuellem Ende weiter
    using var fs = new FileStream("database.bin", FileMode.Append, FileAccess.Write, FileShare.Read,
                                  bufferSize: 1 << 20, options: FileOptions.SequentialScan);
    using var bw = new BinaryWriter(fs, Encoding.UTF8, leaveOpen: true);

    // Start-Key einfach fortlaufend; Kollisionen sind ok (append-only)
    // Wer mag: hier könnte man den letzten Key scannen und +1 starten.
    int key = 1;

    var rnd = Random.Shared;
    var sb = new StringBuilder(capacity: Math.Max(maxLen, 32));

    long startLen = fs.Length;
    long targetLen = targetBytes;

    // Schleife bis Zielgröße erreicht (oder überschritten)
    while (fs.Length < targetLen)
    {
        int len = minLen == maxLen ? minLen : rnd.Next(minLen, maxLen + 1);

        // eine leichte, gut komprimierbare Payload (lesbar & billig zu erzeugen)
        // Beispiel: "v<key>-<counter>-" plus Füllzeichen
        sb.Clear();
        sb.Append('v').Append(key).Append('-');
        // auf Ziel-Länge auffüllen
        while (sb.Length < len) sb.Append('x');
        var data = Encoding.UTF8.GetBytes(sb.ToString());

        bw.Write(key);
        bw.Write(data.Length);
        bw.Write(data);

        key++;

        // Optional: selten flushen, um OS-Buffer zu nutzen
        if ((key & 0x3FFF) == 0) bw.Flush(); // alle ~16k Einträge kurz flush
    }

    bw.Flush();
    fs.Flush(flushToDisk: false);

    Console.Error.WriteLine($"Filled from {FormatSize(startLen)} to {FormatSize(fs.Length)} (target ~{FormatSize(targetLen)}).");
}

static long ParseSize(string s)
{
    // akzeptiert z.B. "2g", "2048m", "2000000000"
    s = s.Trim().ToLowerInvariant();
    if (s.EndsWith("g") || s.EndsWith("gb"))
    {
        var num = s.TrimEnd('g', 'b');
        return (long)(double.Parse(num, System.Globalization.CultureInfo.InvariantCulture) * (1L << 30));
    }
    if (s.EndsWith("m") || s.EndsWith("mb"))
    {
        var num = s.TrimEnd('m', 'b');
        return (long)(double.Parse(num, System.Globalization.CultureInfo.InvariantCulture) * (1L << 20));
    }
    if (s.EndsWith("k") || s.EndsWith("kb"))
    {
        var num = s.TrimEnd('k', 'b');
        return (long)(double.Parse(num, System.Globalization.CultureInfo.InvariantCulture) * 1024L);
    }
    return long.Parse(s); // bytes
}

static string FormatSize(long bytes)
{
    const double KB = 1024, MB = KB * 1024, GB = MB * 1024;
    if (bytes >= GB) return $"{bytes / GB:0.##} GiB";
    if (bytes >= MB) return $"{bytes / MB:0.##} MiB";
    if (bytes >= KB) return $"{bytes / KB:0.##} KiB";
    return $"{bytes} B";
}
